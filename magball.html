<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>4K GLSL Kernel Test</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#fps {
  position:fixed;
  top:8px;
  right:8px;
  color:#0ff;
  font:14px monospace;
  z-index:10;
}
canvas { display:block; }
</style>
</head>
<body>
<div id="fps">FPS</div>
<canvas id="c"></canvas>

<script id="fragShader" type="x-shader/x-fragment">
precision highp float;

uniform vec2 iResolution;
uniform float iTime;
uniform vec2 iMouse;

// Ultra detailed kernel function
float kernal(vec3 a){
    float b,c,d,e,f,g;
    for(int i=0;i<220;i++){
        b = length(a) + 1e-10;
        c = atan(a.y, a.x) * (48.0 + sin(b*14.0));
        d = acos(clamp(a.z / b, -1.0, 1.0)) * (48.0 + cos(b*14.0));
        e = sin(b * 35.0);
        f = cos(b * 35.0);
        g = sin(dot(a,a) * 4.0);
        b = pow(b, 32.0 + e + f + g);
        a = vec3(
            b * sin(d)*cos(c) + a.x*(0.55 + 0.45*sin(b+g)),
            b * sin(d)*sin(c) + a.y*(0.55 + 0.45*sin(b+g)),
            b * cos(d) + a.z*(0.55 + 0.45*sin(b+g))
        );
        if(b>60.0) break;
    }
    return 40.0 - dot(a,a);
}

// Raymarch function
float map(vec3 p){
    return kernal(p);
}

// Camera
vec3 getRayDir(vec2 uv, vec3 ro, vec3 target){
    vec3 forward = normalize(target - ro);
    vec3 right = normalize(cross(vec3(0.0,1.0,0.0), forward));
    vec3 up = cross(forward, right);
    return normalize(uv.x*right + uv.y*up + 2.0*forward);
}

// Main
void main(){
    vec2 uv = (gl_FragCoord.xy/iResolution.xy)*2.0-1.0;
    uv.x *= iResolution.x/iResolution.y;
    
    vec3 ro = vec3(0.0,0.0,5.0);
    vec3 target = vec3(0.0);
    vec3 dir = getRayDir(uv, ro, target);
    
    float t = 0.0;
    float d;
    for(int i=0;i<200;i++){
        d = map(ro + dir*t);
        t += max(d*0.0001, 1e-6);
        if(t>100.0) break;
    }
    
    float col = 1.0/(0.001+t*t*0.05);
    gl_FragColor = vec4(vec3(col),1.0);
}
</script>

<script>
const canvas = document.getElementById("c");
canvas.width = 3840; // 4K width
canvas.height = 2160; // 4K height
const gl = canvas.getContext("webgl");
if(!gl){ alert("WebGL not supported"); }

const fpsEl = document.getElementById("fps");
let last = performance.now(), frames=0;

function updateFPS(t){
    frames++;
    if(t-last>1000){
        fpsEl.textContent = (frames*1000/(t-last)).toFixed(1) + " FPS";
        last = t;
        frames=0;
    }
}

// Compile shader
function compileShader(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(sh));
    }
    return sh;
}

const vertShaderSrc = `
attribute vec2 pos;
void main(){ gl_Position=vec4(pos,0.0,1.0); }
`;

const fragShaderSrc = document.getElementById("fragShader").textContent;

const vs = compileShader(gl.VERTEX_SHADER, vertShaderSrc);
const fs = compileShader(gl.FRAGMENT_SHADER, fragShaderSrc);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(program));
}
gl.useProgram(program);

const posLoc = gl.getAttribLocation(program,"pos");
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

const iResolution = gl.getUniformLocation(program,"iResolution");
const iTime = gl.getUniformLocation(program,"iTime");

let start = performance.now();

function render(){
    const t = (performance.now()-start)*0.001;
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(iResolution,canvas.width,canvas.height);
    gl.uniform1f(iTime,t);
    gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

    updateFPS(performance.now());
    requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
