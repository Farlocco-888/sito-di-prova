<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>MagBall 3D Extreme GPU</title>
<style>
body { margin: 0; overflow: hidden; background: black; }
#fps {
  position: fixed;
  top: 8px;
  right: 8px;
  color: #ff5555;
  font: 14px monospace;
  z-index: 10;
}
canvas { display: block; }
</style>
</head>
<body>
<div id="fps">FPS</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl2");
if (!gl) {
  alert("WebGL2 non supportato");
  throw new Error("WebGL2 no");
}

canvas.width = window.innerWidth * 5;
canvas.height = window.innerHeight * 5;

// Vertex shader: quad fullscreen
const vsSource = `#version 300 es
in vec4 a_position;
void main() {
  gl_Position = a_position;
}`;

// Fragment shader: heavy raymarching of a sphere SDF
const fsSource = `#version 300 es
precision highp float;
out vec4 fragColor;
uniform vec2 u_resolution;
uniform float u_time;

// sphere SDF
float sphereSDF(vec3 p, float r) {
  return length(p) - r;
}

void main() {
  vec2 uv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0;
  uv.x *= u_resolution.x / u_resolution.y;

  vec3 ro = vec3(0.0, 0.0, -3.0);
  vec3 rd = normalize(vec3(uv, 1.5));

  float t = 0.0;
  vec3 color = vec3(0.0);

  // Raymarching
  const int MAX_STEPS = 6000;
  const float SURF_THRESH = 0.0001;
  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 p = ro + t * rd;
    float dist = sphereSDF(p, 1.0);
    if (dist < SURF_THRESH) {
      // surface hit
      color = vec3(0.5 + 0.5*sin(float(i)*0.1 + u_time),
                   0.5 + 0.5*cos(float(i)*0.13 + u_time),
                   0.5 + 0.5*sin(float(i)*0.17 - u_time));
      break;
    }
    t += dist;
  }

  fragColor = vec4(color, 1.0);
}
`;

// compile shader
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    throw new Error("Shader compile failed");
  }
  return shader;
}

// program
const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

// buffer quad
const quadVerts = new Float32Array([
  -1, -1,  1, -1, -1,  1,
   1, -1,  1,  1, -1,  1
]);
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const resLoc = gl.getUniformLocation(program, "u_resolution");
const timeLoc = gl.getUniformLocation(program, "u_time");

let start = performance.now();
let last = start, frames = 0;

function render(now) {
  frames++;
  const dt = now - last;
  if (dt >= 1000) {
    document.getElementById("fps").textContent =
      (frames * 1000 / dt).toFixed(1) + " FPS";
    frames = 0;
    last = now;
  }

  const t = (now - start) * 0.001;
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);

  gl.uniform2f(resLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, t);

  gl.bindVertexArray(vao);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  requestAnimationFrame(render);
}

render(performance.now());
</script>
</body>
</html>
