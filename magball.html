<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>MagBall 3D Extreme WebGPU</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#fps {
  position:fixed;
  top:8px;
  right:8px;
  color:#00ffff;
  font:14px monospace;
  z-index:10;
}
</style>
</head>
<body>
<div id="fps">FPS</div>
<canvas id="c"></canvas>

<script type="module">
if(!navigator.gpu){ alert("WebGPU non supportato"); throw new Error("No WebGPU"); }

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();

const canvas = document.getElementById("c");
canvas.width = window.innerWidth*5; // risoluzione 5x
canvas.height = window.innerHeight*5;

const ctx = canvas.getContext("webgpu");
const format = navigator.gpu.getPreferredCanvasFormat();
ctx.configure({device, format});

let loops = 50; // kernel iterations iniziali

// shader raymarching per MagBall
function makePipeline(){
  const shader = `
struct VertexOut { @builtin(position) pos : vec4<f32>; };
@vertex fn vs(@builtin(vertex_index) i:u32) -> VertexOut {
  var p = array<vec2<f32>,6>(
    vec2<f32>(-1,-1), vec2<f32>(1,-1), vec2<f32>(-1,1),
    vec2<f32>(-1,1), vec2<f32>(1,-1), vec2<f32>(1,1)
  );
  var out : VertexOut;
  out.pos = vec4<f32>(p[i],0.0,1.0);
  return out;
}

@fragment fn fs(@builtin(position) pos:vec4<f32>) -> @location(0) vec4<f32> {
  var uv = pos.xy / vec2<f32>(${canvas.width}.0, ${canvas.height}.0) * 2.0 - 1.0;
  uv.x *= ${canvas.width}.0/${canvas.height}.0;

  var ro = vec3<f32>(0.0,0.0,-3.0);
  var rd = normalize(vec3<f32>(uv,1.5));

  var t = 0.0;
  var col = vec3<f32>(0.0);
  const maxSteps = 6000u; // max ray steps
  const surfaceThreshold = 0.0001;

  for(var i=0u;i<maxSteps;i++){
    var p = ro + rd * t;
    var dist = length(p) - 1.0; // sfera radius 1
    if(dist<surfaceThreshold){
      col = vec3<f32>(0.5 + 0.5*sin(f32(i)*0.1),
                      0.5 + 0.5*cos(f32(i)*0.13),
                      0.5 + 0.5*sin(f32(i)*0.17));
      break;
    }
    t += dist;
  }

  // kernel iterations pesanti
  for(var k=0u;k<${loops}u;k++){
    col = sin(col + f32(k)) * 0.5 + 0.5;
  }

  return vec4<f32>(col,1.0);
}`;

  return device.createRenderPipeline({
    layout: "auto",
    vertex: { module: device.createShaderModule({ code: shader }), entryPoint:"vs" },
    fragment: { module: device.createShaderModule({ code: shader }), entryPoint:"fs", targets:[{format}] },
    primitive:{topology:"triangle-list"}
  });
}

let pipeline = makePipeline();

// auto scale loop aggressivo
setInterval(()=>{ loops += 500; pipeline = makePipeline(); }, 1000);

// FPS
let last=performance.now(), frames=0;
const fpsEl = document.getElementById("fps");

function frame(t){
  frames++;
  if(t-last>=1000){
    fpsEl.textContent = (frames*1000/(t-last)).toFixed(1)+" FPS";
    frames=0;
    last=t;
  }

  const enc = device.createCommandEncoder();
  const pass = enc.beginRenderPass({
    colorAttachments:[{view: ctx.getCurrentTexture().createView(),
      loadOp:"clear", storeOp:"store",
      clearValue:{r:0,g:0,b:0,a:1}}]
  });
  pass.setPipeline(pipeline);
  pass.draw(6);
  pass.end();
  device.queue.submit([enc.finish()]);

  requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>
